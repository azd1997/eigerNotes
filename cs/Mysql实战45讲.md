---
title: "《Mysql实战45讲》速览"
date: 2020-09-04T13:45:49+08:00
draft: false
categories: ["cs"]
tags: ["数据库"]
keywords: ["Mysql"]
---

## 1. 基础架构：一条SQL查询语句是如何执行的？

![mysql45-01-1](/images/mysql45-01-1.png)

一条查询SQL语句`mysql> select * from T where ID=10；`的执行流程：

1. 客户端将请求打给server层
2. **连接器**负责管理连接，权限验证，检查该客户端是否有执行该SQL权限，有则建立连接并继续
3. 首先看**查询缓存**中是否有，有则返回；
4. 无则将SQL交给**分析器**，对SQL语句进行词法分析、语法分析
5. 继续交给**优化器**，负责执行计划生成，索引选择
6. 继续交给**执行器**，执行器操作**存储引擎**（存储引擎独立于server层，负责存储数据，提供读写接口），返回结果。

大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。

- Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

### 1.1 连接器

跟客户端建立连接、获取权限、维持和管理连接

```shell
mysql -h$ip -P$port -u$user -p
**** # 输入密码
```

连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。

- 如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。
- 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。*之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限*。这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

建立连接后若没有后续动作，则连接处于空闲状态，使用`show processlist`可看到该链接`Command`列为`Sleep`

空闲太长时间（超过`wait_timeout`（默认8h）），则连接会被连接器断开。

由于建立连接的过程比较复杂，尽量使用长连接。
    - 全使用长连接后，Mysql内存占用涨得很快，因为MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了
    - 解决方法：
        - 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。
        - 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行`mysql_reset_connection` 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

### 1.2 查询缓存

查询缓存的形式为 <查询语句, 查询结果>。若直接命中，则取缓存结果直接返回。

*不建议使用查询缓存*
    - 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。
    - 对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

MySQL 也提供了这种“按需使用”的方式。可以将参数 `query_cache_type` 设置成 `DEMAND`，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 `SQL_CACHE` 显式指定，像下面这个语句一样：

```sql
mysql> select SQL_CACHE * from T where ID=10；
```

- MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻
底没有这个功能了。

### 1.3 分析器

MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析
    - 分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。
    - “语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法

- 如果语句不对，就会收到“You have an error in your SQL syntax”的错误，一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。

### 1.4 优化器

经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。

- 优化器是在表里面有多个索引的时候，决定使用哪个索引
- 或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段

### 1.5 执行器

MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

1. 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。
    - 也就是说：命中查询缓存返回之前、优化器之前会precheck、执行器执行之前 都有做权限检查
2. 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，扫描*所有可能存在结果的数据行*(对于没索引情况，则是顺序遍历所有行，有索引则是借助索引树遍历所有符合索引条件的行)。 

你会在数据库的慢查询日志中看到一个 `rows_examined` 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此*引擎扫描行数跟`rows_examined` 并不是完全相同的*。

### 提问

如果表 T 中没有字段 k，而你执行了这个语句 select * from T
where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？

*A: 分析器。在分析阶段判断语句是否正确，表是否存在，列是否存在等*

## 2. 日志系统：一条SQL更新语句是如何执行的？

考虑更新语句如下：

```sql
// ID主键， c整型
mysql> update T set c=c+1 where ID=2;
```

更新语句和查询语句一样需要经过“连接器->分析器->优化器->执行器”，但还涉及两个重要的日志模块：**redo log（重做日志）和 binlog（归档日志）**

- 别忘了，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空

### 2.1 redo log

如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。

因此，Mysql采用**WAL（Write-Ahead Log）**技术。**先写日志，再写磁盘**。 

**InnoDB有redolog。（换句话说redolog是InnoDB特有的日志）**

具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

![mysql45-02-1](/images/mysql45-02-1.png)

- write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

- write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示四个redolog没有可写的位置，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。
- 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。或者叫CFT（Crash Fault Tolerant, 崩溃容错）

### 2.2 binlog

**binlog 是Mysql Server层的日志， 称归档日志**。Mysql一开始只有binlog，不支持崩溃安全，后来InnoDB使用redolog实现崩溃安全。

binlog与redolog的区别：
1. redolog是InnoDB特有；binlog为server层实现，所有引擎均可使用
2. redolog是物理逻辑，记录**“在某个数据页上做了什么修改”**；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1”
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 

### 2.3 考虑redolog和binlog的更新语句流程

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

![mysql45-02-2](/images/mysql45-02-2.png)

- 注意：写redolog拆分成两步（两阶段提交）：实际写并标记prepare -> 执行器提交事务后引擎将状态更新为commit

### 2.4 两阶段提交

如果redolog不使用**两阶段提交**， 那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。
- 误操作之后需要根据日志恢复Mysql
- 扩容（常见做法是全量备份加应用binlog）也需要。扩容时如果不是两阶段提交，会导致线上主从数据库不一致

```
由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。

仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设 执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？

1. 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。

2. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。
```

redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

### 建议

- redo log 用于保证 crash-safe 能力。`innodb_flush_log_at_trx_commit` 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。

- `sync_binlog` 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

### 提问

1. 如果要实现 “MySQL 可以恢复到半个月内任意一秒的状态”， 怎么操作？

```
A: 

前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

    1. 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
    2. 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。

这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。
```

2. 定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？

```
A:

一天一备 “最长恢复时间”更短。 
一天一备情况下最坏情况下需要应用一天的binlog。 而一周一备最坏情况下需要应用一周的binlog，“RTO”（恢复目标时间）更长

而 更频繁的全量备份 也意味着 需要更多存储空间
```

## 3. 事务隔离：为什么你改了我还看不见？

**事务就是要保证一组数据库操作，要么全部成功，要么全部失败。** 在 MySQL 中，事务支持是*在引擎层实现*的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。

### 3.1 隔离性与隔离级别

- 事务 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、**隔离性**、持久性）
    - 上一节提到的redolog和binlog保证了事务的持久性
- 多个事务同时执行的时候，就可能出现**脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）**的问题，为了解决这些问题，就有了“隔离级别”的概念。

SQL 标准的事务隔离级别：

- **读未提交**（read uncommitted）。 是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- **读提交**（read committed）。 是指，一个事务提交之后，它做的变更才会被其他事务看到。
- **可重复读**repeatable read）。 是指，一个事务执行过程中看到的数据，总是**跟这个事务在启动时看到的数据是一致的**。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- **串行化**（serializable ）。顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

