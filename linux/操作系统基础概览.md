---
title: "操作系统基础概览"
date: 2020-09-05T19:23:07+08:00
draft: false
categories: ["cs"]
tags: ["操作系统"]
keywords: ["操作系统"]
---

## 1. 内存管理

### 1.1 虚拟内存

操作系统 为每个进程分配一套独立的**虚拟地址** 来把进程使用的地址**隔离**开。

- 虚拟内存地址
- 物理内存地址

虚拟内存地址 经过CPU中的MMU（内存管理单元） 转换为物理地址

虚拟地址与物理地址间关系有两种管理方式：内存分段、内存分页

### 1.2 内存分段

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用**分段**（Segmentation）的形式把这些段分离出来。

分段机制下的虚拟地址由两部分组成： **段选择子**和**段内偏移量**。
    - 段选择子： `段号 | 特权等标志位`
    - 段选择子保存在 段寄存器 中
    - 段号用于在 段表 中索引 段内描述符。 <段号, 段内描述符>
    - 段内描述符： `段基地址 | 段界限 | 特权级DPL`
    - 段内偏移量 范围 [0, 段界限]。 若段内偏移量合法，则 `物理地址 = 段基地址 + 段内偏移量`
分段机制会把程序的虚拟地址分成 4 个段 （从低到高为：代码段、数据段、堆段、栈段） ，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址  

- 好处：
    - 程序不需要关心具体的物理内存分配地址问题。易于开发、维护
    - 内存可以**用时分配**(惰性分配)，执行效率和内存利用率更好
    - 进程间空间隔离，安全
    - 
- 缺点：
    - 内存碎片
        - 外部内存碎片。 较小的程序其内存回收之后中间的空位不足以运行较大的程序
        - 内部内存碎片。 
    - 内存交换效率低    

解决外部内存碎片的问题就是内存交换，其实就是把不连续的内存段交换到磁盘，再交换回内存，把使用的内存段连续排布，这个过程可以称为“内存碎片整理”，这样就可以消除外部内存碎片碎片。linux的swap分区就用于内存交换。

问题在于：有的时候段很大，交换的时间消耗比较高，机器就会卡顿。

为了解决这两个问题，内存分页机制产生

### 1.3 内存分页

分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。

要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是**内存分页**（Paging）。

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。

虚拟地址与物理地址之间通过页表来映射

页表实际上存储在 CPU 的内存管理单元 （MMU）

当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

分页如何解决碎片问题？
- 内存空间预先划分为固定大小的“页”，意味着不会产生非常小的页，空出来的内存以页为单位，足以给进程使用。
- 内存不足时，须按照页面置换算法来“换入换出”。由于一次性写磁盘的只有少数一个或几个页，不会花太多时间，内存交换效率较高
- 分页机制允许在建立虚拟页与物理页之间映射之后不把页加载到物理内存，而是当程序运行中，需要用到对应虚拟页中指令和数据时再加载。

分页机制中 虚拟内存与物理内存的映射？
- 虚拟地址：`页号 | 页内偏移量`
- 根据页号，从页表查物理页号
- 物理内存地址：`物理页号 + 页内偏移量`

简单的分页存在什么问题？
- 空间上的缺陷。32位系统，虚拟空间4GB，4kB一页，需要2^20（约100万）个页，每个页表项需要4B，那么一个进程的虚拟空间就需要 100万 * 4B = 4MB存储页表。而操作系统通常有很多进程同时运行。64位系统就更恐怖了

多级页表：
- 道理的话，和跳表建立索引差不多。简单页表为了覆盖4GB空间，一个页表项对应一页，而多级页表中一级索引同样也要覆盖4GB空间，但是每个页表项指向的区域是个比较大的区域，比如100个页的连续空间
- 由于对大多数程序来说，实际使用空间远不足4GB，也就是有很多页表项都是空的，并且已使用的页表项可以分配到连续的地方。（局部性原理）。
- 根据前两点，不光是内存可以用时分配，连虚拟内存页的页表也可以用时分配
- 对于64位系统。两级分页不够，使用了四级分页：全局页目录项PGD、上层页目录项PUD、中间页目录项PMD、页表项PTE

TLB:
- 多级页表节省了内存，但是地址转换效率降低。
- 由于程序局部性，一段时间内程序执行仅限程序中某一部分，相应地，执行所访问的存储空间也局限于某个区域
- 因此可以把最长访问的几个页表项存储到TLB。TLB是CPU芯片中专门存这些最常访问页表项的硬件缓存，称页表缓存、转址旁路缓存、快表。
- 现在寻址顺序变为了：CPU寻址先查TLB，没命中缓存再查常规页表

### 1.4 段页式内存管理

段页式内存管理实现的方式：

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；

这样，地址结构就由**段号、段内页号和页内位移**三部分组成。

用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号

段页式地址变换中要得到物理地址须经过三次内存访问：

1. 第一次访问段表，得到页表起始地址；
2. 第二次访问页表，得到物理页号；
3. 第三次将物理页号与页内位移组合，得到物理地址。
可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。

### 1.5 Linux内存管理

Intel x86架构 CPU 采用了段页式，内置了段式MMU和页式MMU。地址转换如下
1.  程序使用的“逻辑地址” 经段式MMU转换得到 “线性地址/虚拟地址”
2. “线性地址/虚拟地址” 经页式MMU转换得到物理地址

Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。

Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

Linux虚拟地址空间分布：
- 分为内核空间和用户空间两部分
- 32位系统的内核空间1G，位于最高处；用户空间3G，剩余位置
- 64位系统内核空间和用户空间均128T， 内核空间在最高处，用户空间在最低处，中间的大段空间未定义

再来说说，内核空间与用户空间的区别：
- 进程在用户态时，只能访问用户空间内存；
- 只有进入内核态后，才可以访问内核空间的内存；

虽然每个进程都各自有独立的虚拟内存，但是**每个虚拟内存中的内核地址，其实关联的都是相同的物理内存**。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。

用户空间内存，从低到高分别是 7 种不同的内存段：
- 程序文件段，包括二进制可执行代码；
- 已初始化数据段，包括静态常量；
- 未初始化数据段，包括未初始化的静态变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；

在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。

## 2. 进程与线程