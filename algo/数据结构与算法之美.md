---
title: "《数据结构与算法之美》速览"
date: 2020-09-03T16:34:12+08:00
draft: false
categories: ["算法"]
tags: ["数据结构","算法"]
keywords: ["数据结构", "算法"]
---

## 1. 时间复杂度与空间复杂度

### 知识点

- 大$O$表示法  $O(f(n))$
- 时间复杂度分析
    - 只关注循环执行次数最多的一段代码
    - 加法法则：总复杂度等于量级最大的那段代码的复杂度
    - 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
- 常见时间复杂度：O(1)/O(n)/O(logn)/O(nlogn)/O(m+n)/O(m*n)
- 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系
- 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系
- 最好时间复杂度/最坏时间复杂度/平均时间复杂度/均摊时间复杂度(摊还分析)

### 练习

递推公式

```
T(n)=1, n=1
T(n)=4T(n/2)+n, n>1
```
的时间复杂度为:

```
O(n^2)
参考: https://www.nowcoder.com/test/question/done?tid=36925642&qid=305020#summary
```

## 2. 数组

- 线性表结构代表
- 支持随机访问
- 插(O(n))/追加(O(1))/删(O(n))/改查(按下标则是O(1)，按值则是O(n))
- 优化
    - 插入：预分配空间
    - 删除：标记删除，而非真正删除。（空闲时批量整理）
- 警惕数组越界：C语言不会检查下标越界
- 下标从0开始：
    - 减少一次求地址的减法运算
    - 历史原因（C这么搞，后来者模仿）    

## 3. 链表

- 经典应用场景：缓存
    - 缓存淘汰策略：LRU(最近最少使用)/LFU(最少使用)/FIFO(先进先出)
- 单链表
- 循环链表
    - 约瑟夫环问题
- 双向链表
- 双向循环链表
- 插入(O(1))/删除(O(1))/改(O(1))/查(O(n))
- 实现链表的注意点：
    - 理解指针/引用的含义
    - 警惕指针丢失(注意操作顺序)和内存泄漏(删除节点后手动释放内存)
    - 利用哨兵节点简化实现难度
    - 重点留意边界情况处理
        - 链表空
        - 链表只有1个节点
        - 链表只有两个节点
        - 处理到链表头结点和尾节点时
        - ...
    - 举例画图，辅助思考
    - 多写多练
        - 单链表反转
        - 链表中环检测
        - 有序链表合并
        - 删除链表倒数第n个节点
        - 求链表的中间节点

## 4. 栈

- 典型应用： 
    - 浏览器的前进后退（两个栈，倒来倒去）
    - 函数调用栈
    - 计算器（表达式求值）
    - 括号匹配
    - 两个栈实现队列
    - 共享一个数组内存的两个栈（两端向内增长）
- 先进后出
- 顺序栈（数组实现）； 链式栈（链表实现）
- 动态扩容的数组栈
- 栈与操作系统中堆栈的区别：操作系统中堆与栈并不是真的堆、栈结构，都只是内存空间的两块线性空间

## 5. 队列

- 典型应用： 有限资源池
- 先进先出
- 顺序队列、链式队列
- 基于数组的循环队列
    - 抽象成环形
    - 浪费一个空间
    - 队列满：head = tail 
    - 队列空：(tail + 1) % n = head。 （这里n是实际数组长度，而不是可用长度）
- 阻塞队列： 生产者-消费者
- 并发队列
    - 加锁实现
    - 无锁实现
        - CAS（Compare And Swap）。入队前获取tail位置，入队时比较tail是否发生变化，否则入队，是则入队失败。 相应地，出队则是获取head位置及比较
        - 类似于Disruptor，利用申请批量内存的操作系统锁实现并发安全，用户程序中不需要锁

## 6. 递归

