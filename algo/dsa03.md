---
title: "数据结构与算法（3）——链表"
date: 2019-10-18T03:22:06+08:00
draft: false
categories: ["algo"]
tags: ["数据结构"]
keywords: ["链表"]
---

## 1. 导语

链表的一个经典应用场景是**LRU缓存淘汰算法**

缓存提高数据读取性能，应用广泛，常见的有CPU缓存、数据库缓存、浏览器缓存。
缓存大小有限，当缓存满时，哪些数据应该被清理掉？这就是缓存淘汰算法（策略）的由来。
常见的缓存淘汰策略有：先进先出策略（First In and First Out, FIFO）、最少使用策略（Least Frequently Used, LFU）、最近最少使用策略（Least Recently Used, LRU）。
缓存淘汰策略就像是清理我们清理买过的书或是衣服，是很久以前买的那些优先丢掉呢还是很少使用的那些丢掉呢，这是一样的道理。
那么，如何使用链表实现LRU最少最近使用缓存淘汰策略呢？

## 2. 链表的底层结构

链表，顾名思义，就是一个个数据用“绳子”连起来，成为“链”。
数组的底层结构采用连续内存，而链表则可以是不连续的零碎的内存空间（至于怎么去分配内存地址则是编译器等的事，暂时不管）。
由此可知，假如一台设备内存上没有连续的1GB可用空间，哪怕拥有超过1GB的总可用空间，也没有办法存储1GB大小的数组内容。而链表则不受此限制。

再来说“绳子”。“绳子”是为了找到下一个数据块，由于内存中的数据是通过内存地址编号访问的，所以这个“绳子”就是下一个数据块存储的首地址。
所以链表中每一个数据块包括两个部分： 数据域和指针域。 数据域存储我们需要的数据，而指针域用来指向下一个数据块。
由于链表的这个描述，我们可以想象链上有一个一个的绳结，从术语讲，把前面说的链表的数据块称为“结点”。

![dsa03-1](/images/dsa03-1.png)
<!--![dsa03-1](../../../static/images/dsa03-1.png)-->

数组和链表的底层结构大体可由上图解释（上图链表中省去了指针存储的区域）

链表的结构五花八门，其实根据个人实现的不同会呈现很多不一样的链表。但最常见的是三种：**单（向）链表**、**双（向）链表**、**循环链表**。
其各自的结构见下图示：

![dsa03-2](/images/dsa03-2.jpg)
<!--![dsa03-2](../../../static/images/dsa03-2.png)-->

![dsa03-4](/images/dsa03-4.jpg)
<!--![dsa03-4](../../../static/images/dsa03-4.png)-->

![dsa03-5](/images/dsa03-5.jpg)
<!--![dsa03-5](../../../static/images/dsa03-5.png)-->

通常来讲，链表会有**头结点**、**尾结点**两个特殊结点（具体怎么样取决于自己怎么实现，不必拘泥）。
头结点的数据域为空，指针域指向真正的第一个数据所在的数据块。
尾结点的数据域为最后一个数据，指针域却为空。

## 3. 链表的操作

链表也支持增删查。

上一节讲到数组支持**根据下标随机访问**，实现O(1)的查找时间复杂度。那么链表呢？

考虑链表


## 4. LRU缓存淘汰算法实现


